---
title: 【编程基础】04.拒绝重复造轮子-函数
sidebar: 04.函数
date: 2026-02-06
tags: [ 编程基础, 函数, 代码复用, 封装, Java, Lambda ]
---

# 拒绝重复造轮子：函数——你的高效代码工厂

如果你发现自己正在不停地按下 `Ctrl+C` 和 `Ctrl+V`，那么警报已经拉响：你的代码正在走向失控。

### 第一幕：复制粘贴的噩梦

假设你正在写一个“计算圆形面积”的功能。
第一次，你写了 `3.14 * r * r`；第二次，你又写了一遍。
就在你写完第一百次时，老板突然说：“为了精确，把 3.14 改成 3.1415926。”

看着满屏幕需要修改的地方，你意识到：**你需要的不是体力活，而是一个“模具”。**

---

### 第二幕：黑盒工厂 —— 封装的艺术

你决定把这段逻辑封存起来，并给它起个名字。这就是**函数（Function）**，在 Java 中也叫**方法（Method）**。

你只需要定义一次，以后每当需要它，喊它的名字就行。

:::code-group

```java [AreaCalculator.java]
// 定义这个“模具”
void calculateArea() {
    double r = 5.0;
    System.out.println(3.14 * r * r);
}

// 以后只需要“喊名字”即可调用
calculateArea(); 
```

:::

**恭喜你，学会了“封装”。** 你从一个辛苦的“搬砖工”，变成了运筹帷幄的“工厂主”。

---

### 第三幕：给工厂喂原料 —— 参数

但很快你发现，上面的工厂太死板了，它只能算半径为 5 的圆。你希望这个工厂更通用：我给你什么半径，你就帮我算什么圆。

于是，你给函数开了个“投料窗口”，这就是**参数（Parameter）**。

:::code-group

```java [AreaCalculator.java]
void calculateArea(double radius) { // 接收“投料”
    System.out.println(3.14 * radius * radius);
}

// 算大圆
calculateArea(10.0); 
// 算小圆
calculateArea(1.5);  
```

:::

**参数让你的代码具备了处理不同情况的能力。**

---

### 第四幕：产出结果 —— 返回值

有时候，你不需要函数直接把结果打印出来，而是希望它把算好的数值**还给你**，让你去进行下一步计算（比如计算球体的体积）。

这时候，你需要一条“成品传送带”，即 **返回值（Return Value）**。

:::magic-code-group

```java [AreaCalculator.java]
// 之前的工厂：只管打印，不吐结果
void calculateArea(double radius) {
    System.out.println(3.14 * radius * radius);
}
```

```java [AreaCalculator.java]
// 现在的工厂：产出结果，交还给调用者
double getArea(double radius) {
    return 3.14 * radius * radius; 
}

// “接住”这个结果，用于后续逻辑
double myArea = getArea(5.0);
```

:::

**恭喜你，完成了逻辑的“闭环”。** 函数不再只是个喇叭，而是一个可以嵌套、组合的智能单元。

---

### 第五幕：极简主义的现代美学 —— Lambda

在现代编程（Java 8+ 或 JavaScript/Python）中，如果你觉得写这么多行包装还是太繁琐，你可以用更酷的方式：**Lambda 表达式**。

不需要名字，不需要繁琐的类包装，一行搞定逻辑。

:::magic-code-group

```javascript [main.js]
// 现代的箭头函数 (Arrow Function)
const getArea = (r) => 3.14 * r * r;

console.log(getArea(5));
```

```java [LambdaExample.java]
// Java 中的 Lambda 简写（配合函数式接口）
Function<Double, Double> calculateArea = r -> 3.14 * r * r;
```

:::

**代码从此变得像诗一样简洁。**

---

### 结尾：工具箱的诞生

函数，是程序员拒绝重复的终极武器。它把复杂的逻辑打碎，变成一个个精巧的工具。

当你拥有了一整套工具箱（登录、加密、绘图、计算），你就再也不用从零开始造轮子了。

但是，当你的工具和数据越来越多，该如何整齐地存放它们，而不是乱丢在地上呢？
**下一站，我们要走进“储物柜的艺术”——顺序存储（数组）。**

---
*(本文整理自《程序员的入场券》系列教程)*
